#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
from discord.ext import commands
from sausage_bot.funcs import _vars
from sausage_bot.funcs import rss_core, discord_commands, net_io
from sausage_bot.log import log


class AutoEvent(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.group(name='autoevent', aliases=['event'])
    async def autoevent(self, ctx):
        '''***'''
        pass

    @commands.check_any(
        commands.is_owner(),
        commands.has_permissions(administrator=True)
    )
    @autoevent.group(name='add')
    async def add(self, ctx, url=None, channel=None):
        SCRAPE_OK = False
        CHANNEL_OK = False
        if url is None or\
                channel is None:
            await ctx.send(_vars.TOO_FEW_ARGUMENTS)
            return
        else:
            scraped_info = net_io.parse(url)
            if scraped_info is None:
                SCRAPE_OK = False
            else:
                SCRAPE_OK = True
            voice_channels = discord_commands.get_voice_channel_list()
            log.log_more(f'Getting channel list:\n{voice_channels}')
            if channel in voice_channels:
                CHANNEL_OK = True
            if SCRAPE_OK and CHANNEL_OK:
                scr = scraped_info
                print(scr)
                sys.exit()
#                # Start creating the event
#                home = scr['teams']['home']
#                away = scr['teams']['away']
#                tournament = scr['tournament']
#                datetime = scr['datetime']
#                stadium = scr['stadium']
#                await ctx.guild.create_scheduled_event(
#                    name = f'Kampchat - {home} vs {away}',
#                    description = f'Turnering: {tournament}\n'\
#                        f'NÃ¥r: {datetime}\n'\
#                        f'Hvor: {stadium}',
#                    channel = channel,
#                    start_time = scr['datetime']['startdt'],
#                    end_time = scr['datetime']['enddt'],
#                    reason = 'autogenerated event'
#                )

    @commands.check_any(
        commands.is_owner(),
        commands.has_permissions(administrator=True)
    )
    @autoevent.group(name='remove')
    async def remove(self, ctx, feed_name):
        '''***'''
        AUTHOR = ctx.message.author.name
        removal = rss_core.remove_feed_from_file(
            feed_name, _vars.rss_feeds_file)
        if removal:
            await log.log_to_bot_channel(
                _vars.RSS_REMOVED_BOT.format(feed_name, AUTHOR)
            )
            await ctx.send(
                _vars.RSS_REMOVED.format(feed_name)
                )
        elif removal is False:
            # Couldn't remove the feed
            await ctx.send(_vars.RSS_COULD_NOT_REMOVE.format(feed_name))
            # Also log and send error to either a bot-channel or admin
            await log.log_to_bot_channel(
                _vars.RSS_TRIED_REMOVED_BOT.format(AUTHOR, feed_name)
            )
        return


    @autoevent.group(name='list')
    async def list_rss(self, ctx, long=None):
        if long is None:
            list_format = rss_core.get_feed_list(_vars.rss_feeds_file)
        elif long == 'long':
            list_format = rss_core.get_feed_list(_vars.rss_feeds_file, long=True)
        await ctx.send(list_format)
        return


def setup(bot):
    # Create necessary files before starting
#    log.log_more('Creating necessary files')
#    check_and_create_files = [
#        (_vars.rss_feeds_file, '{}'),
#        _vars.rss_feeds_logs_file
#    ]
#    for file in check_and_create_files:
#        if isinstance(file, tuple):
#            file_io.ensure_file(file[0], file_template=file[1])
#        else:
#            file_io.ensure_file(file)
    # Starting the cog
    bot.add_cog(AutoEvent(bot))
